"""
Use Keycloak groups to add Google Workspace calendars to users' calendar
lists on https://calendar.google.com.

A KeyCloak group is a "calendar group" if it is a direct subgroup of
/calendars (link:Ish1u6Xo) and it defines one or more "gws_calendar_id"
(link:quaZ0hc1) attributes (which correspond to Google Calendar IDs)

The subscription role/permission is based on whether the user is a member
of the calendar group's "readers" or "writers" subgroup (link:ahPhe3x2).

Subgroups other than the ones described here are ignored.

Calendar owners are assumed to be managed out-of-band and are ignored.

Only individual users of a calendar are managed (Google Workspace groups
and domains are ignored).

If a user "unsubscribes" from a calendar after it's been added, this script
will not make the calendar reappear in the user's calendar list.

Users can optionally be notified via email of being added/removed/changed.

A good guide for setting up a Google Workspace service account:
https://yagisanatode.com/how-to-force-subscribe-a-user-in-your-domain-to-a-google-calendar-in-google-apps-script/

This code uses custom keycloak attributes that are documented here:
https://bookstack.icecube.wisc.edu/ops/books/services/page/custom-keycloak-attributes

Google Calendar API described here:
https://googleapis.github.io/google-api-python-client/docs/dyn/calendar_v3.html

Example::
    python -m actions.sync_gws_calendars --sa-credentials service-account.json \
        --sa-subject gws-super-admin@icecube.wisc.edu --dryrun
"""
import asyncio
import logging
import sys

from collections import namedtuple, defaultdict
from contextlib import suppress
from pprint import pformat

from google.oauth2 import service_account
from googleapiclient.discovery import build

from krs.email import send_email
from krs.token import get_rest_client
from krs.groups import get_group_membership, group_info, GroupDoesNotExist

from actions.util import retry_execute


ACTION_ID = 'sync_gws_calendars'
logger = logging.getLogger(f'{ACTION_ID}')

ATTR_CAL_ID = "gws_calendar_id"  # link:quaZ0hc1

MSG_FOOTER = f"\n\nThis message has been generated by the {ACTION_ID} robot."

CALENDAR_ADDED_MSG = """
{addr} has been subscribed to the following calendar(s) as a {role}
because you are a member of the corresponding subgroup of {group}.

{calendars}
""" + MSG_FOOTER

CALENDAR_REMOVED_MSG = """
{addr} has been unsubscribed from the following calendar(s)
because you are no longer a member of any subgroups of {group}.

{calendars}
""" + MSG_FOOTER

CALENDAR_ROLE_CHANGED_MSG = """
{addr}'s role has changed to {role} for the following calendar(s)
because you were added or removed from the corresponding subgroup of
{group}.

{calendars}
""" + MSG_FOOTER

ChangeLog = namedtuple('ChangeLog', 'added updated removed')


def get_cal_info_text(cal_ids, calendars_res):
    """Get a text block with summary (name) and descriptions of calendars.

    Args:
        cal_ids (list[str]): List of Google Calendar IDs
        calendars_res: Google Calendar API "calendars" resource.
    Returns:
        str: calendar descriptions
    """
    cal_infos = []
    for cal_id in cal_ids:
        req = calendars_res.get(calendarId=cal_id)
        metadata = retry_execute(req)
        if metadata.get('description'):
            cal_infos.append(f"{metadata['summary']}: {metadata.get('description')}")
        else:
            cal_infos.append(f"{metadata['summary']}")
    return '\n'.join(sorted(cal_infos))


def get_gws_cal_user_acl_rules(calendar_id, calendar_acl_res):
    """Get a filtered list of Google Calendar ACL rules.

    We filter out rules we are not supposed to deal with.

    Args:
        calendar_id (str): Google Calendar ID
        calendar_acl_res: Google Calendar API "acl" resource
    Returns:
        dict: Calendar ACL rules keyed by email
    """
    acl_rules = {}
    request = calendar_acl_res.list(calendarId=calendar_id)
    while request is not None:
        response = retry_execute(request)
        logger.debug(f"get_gws_cal_user_acl_rules response\n{pformat(response)}")
        for item in response.get('items', []):
            if (item['kind'] != 'calendar#aclRule'
                    or item['id'].endswith('@group.calendar.google.com')
                    or item['scope']['type'] != 'user'):
                continue
            addr = item['scope']['value']
            acl_rules[addr] = {'role': item['role'],
                               'scope': item['scope'],
                               'id': item['id']}
        request = calendar_acl_res.list_next(request, response)
    return acl_rules


async def get_kc_user_acl_rules(group, role, keycloak):
    """Construct a list of user Calendar ACL rules from a Keycloak calendar group.

    Args:
        group (dict): Standard Keycloak group representation
        role (str): Calendar role
        keycloak: Keycloak REST client
    Returns:
        dict: Calendar ACL rules keyed by email
    """
    try:
        role_usernames = await get_group_membership(f"{group['path']}/{role}s", rest_client=keycloak)  # link:ahPhe3x2
    except GroupDoesNotExist:
        role_usernames = []
    acl_rules = {}
    for username in role_usernames:
        email = f"{username}@icecube.wisc.edu"
        acl_rules[email] = {'role': role,
                            'scope': {'type': 'user',
                                      'value': f'{username}@icecube.wisc.edu'}}
    return acl_rules


async def sync_gws_calendars(calendar_acl, calendar_cals, keycloak, creds, dryrun, notify):
    """Add/remove calendars to users' calendar lists based on KeyCloak calendar groups.

    Args:
        calendar_acl: Google Calendar API "acl" resource
        calendar_cals: Google Calendar API "calendars" resource
        keycloak: Keycloak REST client
        creds: Google Workspace service account credentials
        dryrun (bool): dryrun
        notify (bool): send notification emails
    """
    cal_root_group_info = await group_info('/calendars', rest_client=keycloak)
    kc_cal_groups = [g for g in cal_root_group_info['subGroups'] if ATTR_CAL_ID in g['attributes']]

    for kc_cal_group in kc_cal_groups:
        if not (cal_ids := kc_cal_group.get('attributes', {}).get(ATTR_CAL_ID)):
            logger.debug(f"Skipping {kc_cal_group['path']} because it doesn't have {ATTR_CAL_ID} attribute.")
            continue
        if isinstance(cal_ids, str):
            cal_ids = [cal_ids]
        logger.debug(f"Processing {kc_cal_group['path']} {cal_ids}")

        kc_writer_rules = await get_kc_user_acl_rules(kc_cal_group, "writer", keycloak)
        kc_reader_rules = await get_kc_user_acl_rules(kc_cal_group, "reader", keycloak)
        target_rules = kc_reader_rules | kc_writer_rules

        # change log is used to generate notifications
        change_log = ChangeLog(defaultdict(list), defaultdict(list), defaultdict(list))
        for cal_id in cal_ids:
            cal_meta = retry_execute(calendar_cals.get(calendarId=cal_id))
            change_log = await sync_gws_calendar(cal_id=cal_id,
                                                 cal_name=cal_meta['summary'],
                                                 calendar_acl=calendar_acl,
                                                 target_rules=target_rules,
                                                 creds=creds,
                                                 change_log=change_log,
                                                 dryrun=dryrun)

        # Notify users of changes. In most cases, a user will experience the same
        # change (add/update/remove) for all calendars associated with the keycloak
        # group. However, we can't assume that because a user may be an owner of a
        # subset of the group's calendars, or new users may have been added AND
        # new calendars may have been added/removed between runs of this script.
        for addr, cids in change_log.added.items():
            logger.info(f"Notifying {addr} of being subscribed to new cals ({dryrun=}, {notify=})")
            cal_descr = get_cal_info_text(cids, calendar_cals)
            if notify and not dryrun:
                send_email(addr, "You have been subscribed to WIPAC calendars",
                           CALENDAR_ADDED_MSG.format(addr=addr, calendars=cal_descr,
                                                     role=target_rules[addr]['role'],
                                                     group=kc_cal_group['path']))

        for addr, cids in change_log.updated.items():
            logger.info(f"Notifying {addr} of role change ({dryrun=}, {notify=})")
            cal_descr = get_cal_info_text(cids, calendar_cals)
            if notify and not dryrun:
                send_email(addr, "Your permissions for some WIPAC calendars have changed",
                           CALENDAR_ROLE_CHANGED_MSG.format(addr=addr, calendars=cal_descr,
                                                            role=target_rules[addr]['role'],
                                                            group=kc_cal_group['path']))

        for addr, cids in change_log.removed.items():
            logger.info(f"Notifying {addr} of removal ({dryrun=}, {notify=})")
            cal_descr = get_cal_info_text(cids, calendar_cals)
            if notify and not dryrun:
                send_email(addr, "You have been subscribed to new WIPAC calendars",
                           CALENDAR_ROLE_CHANGED_MSG.format(addr=addr, group=kc_cal_group['path'],
                                                            calendars=cal_descr))


async def sync_gws_calendar(cal_id, cal_name, calendar_acl, target_rules, creds, change_log, dryrun):
    """Update ACLs of a single calendar and add it to users' calendar lists if appropriate.

    Args:
        cal_id (str): Google Calendar ID
        cal_name (str): Google Calendar name ("summary")
        calendar_acl: Google Calendar API "acl" resource
        target_rules (dict): Google Calendar ACL rules that the calendar ought to have
        creds: Google Workspace service account credentials
        change_log (ChangeLog): Data structure for logging applied changes
        dryrun (bool): dryrun
    """
    actual_rules = get_gws_cal_user_acl_rules(cal_id, calendar_acl)
    logger.debug(f"{target_rules=}")

    # Owners are managed out of band. Exclude them from actual and target ACL rules.
    owners = set(addr for addr, rule in actual_rules.items() if rule["role"] == "owner")
    target_rules = target_rules.copy()
    for owner_addr in owners:
        logger.debug(f"Excluding owner {owner_addr} of '{cal_name}'")
        actual_rules.pop(owner_addr)
        with suppress(KeyError):
            target_rules.pop(owner_addr)
    logger.debug(f"{actual_rules=}")
    logger.debug(f"{target_rules=}")

    # Remove extraneous subscribers.
    for extraneous_addr in set(actual_rules) - set(target_rules):
        change_log.removed[extraneous_addr].append(cal_id)
        logger.info(f"Removing extraneous {extraneous_addr} from '{cal_name}' ({dryrun=})")
        if dryrun:
            continue
        req = calendar_acl.delete(calendarId=cal_id, ruleId=actual_rules[extraneous_addr]['id'])
        retry_execute(req)

    # Update roles of existing subscribers if needed.
    for existing_addr in set(actual_rules).intersection(set(target_rules)):
        if actual_rules[existing_addr]['role'] == target_rules[existing_addr]['role']:
            continue
        change_log.updated[existing_addr].append(cal_id)
        logger.info(f"Change {actual_rules[existing_addr]} to {target_rules[existing_addr]} of {cal_name} ({dryrun=})")
        if dryrun:
            continue
        req = calendar_acl.patch(calendarId=cal_id, ruleId=actual_rules[existing_addr]['id'],
                                 body=target_rules[existing_addr])
        retry_execute(req)

    # Add missing subscribers.
    for missing_addr in set(target_rules) - set(actual_rules):
        logger.info(f"Adding {target_rules[missing_addr]} to '{cal_name}' ({dryrun=})")
        change_log.added[missing_addr].append(cal_id)
        if dryrun:
            continue
        logger.info(f"Inserting ACL {target_rules[missing_addr]} into {cal_name}")
        req = calendar_acl.insert(calendarId=cal_id, body=target_rules[missing_addr], sendNotifications=False)
        retry_execute(req)
        user_creds = creds.with_subject(missing_addr)
        user_cal_list = build('calendar', 'v3', credentials=user_creds, cache_discovery=False).calendarList()
        logger.info(f"Forcing display of calendar '{cal_name}' for {missing_addr}")
        req = user_cal_list.insert(body={'id': cal_id, 'selected': True})
        retry_execute(req)

    return change_log


def main():
    import argparse
    parser = argparse.ArgumentParser(
        description="Add/remove Google Workspace calendars to users' https://calendar.google.com"
                    " calendar lists based on KeyCloak calendar groups."
                    " See file docstring for details."
                    " See code for notification message templates.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--sa-credentials', metavar='PATH', required=True,
                        help='JSON file with service account credentials')
    parser.add_argument('--sa-subject', metavar='EMAIL', required=True,
                        help='Google Workspace super admin')
    parser.add_argument('--log-level', default='info', choices=('debug', 'info', 'warning', 'error'),
                        help='Logging level of the root logger')
    parser.add_argument('--log-level-this', default='info', choices=('debug', 'info', 'warning', 'error'),
                        help='Logging level of this application\'s logger')
    parser.add_argument('--log-level-client', default='warning', choices=('debug', 'info', 'warning', 'error'),
                        help='REST client logging level')
    parser.add_argument('--dryrun', action='store_true', help='dry run')
    parser.add_argument('--notify', action='store_true', help='send email notifications')
    args = vars(parser.parse_args())

    if args['dryrun'] and args['notify']:
        parser.error("Arguments --dryrun and --notify are incompatible")

    logging.basicConfig(level=getattr(logging, args['log_level'].upper()))
    cca_logger = logging.getLogger('ClientCredentialsAuth')
    cca_logger.setLevel(getattr(logging, args['log_level_client'].upper()))
    this_logger = logging.getLogger(ACTION_ID)
    this_logger.setLevel(getattr(logging, args['log_level_this'].upper()))

    keycloak_client = get_rest_client()

    creds = service_account.Credentials.from_service_account_file(
        args['sa_credentials'], scopes=[
            'https://www.googleapis.com/auth/calendar',
            'https://www.googleapis.com/auth/calendar.readonly'])

    super_creds = creds.with_subject(args['sa_subject'])
    calendar_res = build('calendar', 'v3', credentials=super_creds, cache_discovery=False)
    calendar_acl_res = calendar_res.acl()
    calendar_cals_res = calendar_res.calendars()

    asyncio.run(sync_gws_calendars(calendar_acl_res, calendar_cals_res,
                                   keycloak_client, creds,
                                   args['dryrun'], args['notify']))


if __name__ == '__main__':
    sys.exit(main())
