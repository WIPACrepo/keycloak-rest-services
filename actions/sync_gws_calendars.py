"""
Add Google Workspace calendars to users' calendar lists on https://calendar.google.com
based on KeyCloak groups.

A KeyCloak group is a "calendar group" if it is a direct subgroup of /calendars
(link:Ish1u6Xo) and defines one or more "calendar_id" (link:quaZ0hc1) attributes.                                 # link:quaZ0hc1

The subscription role is based on whether the user is a member of the calendar
group's "readers" or "writers" subgroup (link:ahPhe3x2).

Subgroups other than the ones described here are ignored.

Calendar owners are assumed to be managed out-of-band and are ignored.

Only users of a calendar are managed (Google Workspace groups are ignored).

If a user "unsubscribes" from a calendar after it's been added, this script
will not make the calendar reappear in the user's calendar list.

This code uses custom keycloak attributes that are documented here:
https://bookstack.icecube.wisc.edu/ops/books/services/page/custom-keycloak-attributes

Example::
    python -m actions.sync_gws_calendars --sa-credentials service-account.json \
        --sa-subject gws-super-admin@icecube.wisc.edu --dryrun
"""
import asyncio
import logging
import sys

from contextlib import suppress
from google.oauth2 import service_account
from googleapiclient.discovery import build

from krs.token import get_rest_client
from krs.groups import get_group_membership, group_info, GroupDoesNotExist

from actions.util import retry_execute


ACTION_ID = 'sync_gws_calendars'
logger = logging.getLogger(f'{ACTION_ID}')

FOOTER = f"\n\nThis message has been generated by the {ACTION_ID} robot."
SUBSCRIPTION_ADDED = """
{addr} has been subscribed to the following calendar as {role}:

{name}

{descr}
""" + FOOTER


def get_gws_cal_user_acl_rules(calendar_id, calendar_acl_resource):
    acl_rules = {}
    request = calendar_acl_resource.list(calendarId=calendar_id)
    while request is not None:
        response = retry_execute(request)
        for item in response.get('items', []):
            if (item['kind'] != 'calendar#aclRule'
                    or item['id'].endswith('@group.calendar.google.com')
                    or item['scope']['type'] != 'user'):
                continue
            addr = item['scope']['value']
            acl_rules[addr] = {'role': item['role'],
                               'scope': item['scope'],
                               'id': item['id']}
        request = calendar_acl_resource.list_next(request, response)
    return acl_rules


async def get_kc_user_acl_rules(group, role, keycloak):
    try:
        role_usernames = await get_group_membership(f"{group['path']}/{role}s", rest_client=keycloak)  # link:ahPhe3x2
    except GroupDoesNotExist:
        role_usernames = []
    acl_rules = {}
    for username in role_usernames:
        email = f"{username}@icecube.wisc.edu"
        acl_rules[email] = {'role': role,
                            'scope': {'type': 'user',
                                      'value': f'{username}@icecube.wisc.edu'}}
    return acl_rules


async def sync_gws_calendars(gws_admin_creds, keycloak, dryrun, notify):
    cal_root_group_info = await group_info('/calendars', rest_client=keycloak)
    kc_cal_groups = [g for g in cal_root_group_info['subGroups'] if 'calendar_id' in g['attributes']]

    cal_res = build('calendar', 'v3', credentials=gws_admin_creds, cache_discovery=False)
    cal_acl_res = cal_res.acl()
    for kc_cal_group in kc_cal_groups:
        if not (cal_id := kc_cal_group.get('attributes', {}).get('calendar_id')):  # link:quaZ0hc1
            logger.debug(f"Skipping {kc_cal_group['path']} because it doesn't have calendar_id attribute.")
            continue
        logger.debug(f"Processing {kc_cal_group['path']} {cal_id}")

        kc_writer_rules = await get_kc_user_acl_rules(kc_cal_group, "writer", keycloak)
        kc_reader_rules = await get_kc_user_acl_rules(kc_cal_group, "reader", keycloak)
        target_rules = kc_reader_rules | kc_writer_rules

        actual_rules = get_gws_cal_user_acl_rules(cal_id, cal_acl_res)

        # Owners are managed out of band. Exclude them from actual and target ACL rules.
        owners = set(addr for addr, rule in actual_rules.items() if rule["role"] == "owner")
        for owner_addr in owners:
            logger.debug(f"Excluding owner {owner_addr}")
            actual_rules.pop(owner_addr)
            with suppress(KeyError):
                target_rules.pop(owner_addr)
        logger.debug(f"{actual_rules=}")
        logger.debug(f"{target_rules=}")

        # Remove extraneous subscribers.
        for extraneous_addr in set(actual_rules) - set(target_rules):
            logger.info(f"Removing extraneous {extraneous_addr} ({dryrun=})")
            if dryrun:
                continue
            req = cal_acl_res.delete(calendarId=cal_id, ruleId=actual_rules[extraneous_addr]['id'])
            retry_execute(req)

        # Update roles of existing subscribers if needed.
        for existing_addr in set(actual_rules).intersection(set(target_rules)):
            if actual_rules[existing_addr]['role'] == target_rules[existing_addr]['role']:
                continue
            logger.info(f"ACL change {actual_rules[existing_addr]} to {target_rules[existing_addr]} ({dryrun=})")
            if dryrun:
                continue
            req = cal_acl_res.patch(calendarId=cal_id, ruleId=actual_rules[existing_addr]['id'],
                                    body={target_rules[existing_addr]})
            retry_execute(req)

        # Add missing subscribers.
        for missing_addr in set(target_rules) - set(actual_rules):
            logger.info(f"Adding {target_rules[missing_addr]} ({dryrun=})")
            if dryrun:
                continue
            logger.info(f"Inserting ACL")
            req = cal_acl_res.insert(calendarId=cal_id, body=target_rules[missing_addr], sendNotifications=False)
            retry_execute(req)
            user_creds = gws_admin_creds.with_subject(missing_addr)
            user_cal_list = build('calendar', 'v3', credentials=user_creds, cache_discovery=False).calendarList()
            logger.info(f"Forcing display of calendar")
            req = user_cal_list.insert(body={'id': cal_id, 'selected': True})
            retry_execute(req)


def main():
    import argparse
    parser = argparse.ArgumentParser(
        description="Add/remove Google Workspace calendars to users' https://calendar.google.com"
                    " calendar lists based on KeyCloak calendar groups."
                    " See file docstring for details.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--sa-credentials', metavar='PATH', required=True,
                        help='JSON file with service account credentials')
    parser.add_argument('--sa-subject', metavar='EMAIL', required=True,
                        help='Google Workspace super admin')
    parser.add_argument('--log-level', default='info', choices=('debug', 'info', 'warning', 'error'),
                        help='Logging level of the root logger')
    parser.add_argument('--log-level-this', default='info', choices=('debug', 'info', 'warning', 'error'),
                        help='Logging level of this application (not dependencies).')
    parser.add_argument('--log-level-client', default='warning', choices=('debug', 'info', 'warning', 'error'),
                        help='REST client logging level.')
    parser.add_argument('--dryrun', action='store_true', help='dry run')
    parser.add_argument('--notify', action='store_true', help='notify')
    args = vars(parser.parse_args())

    logging.basicConfig(level=getattr(logging, args['log_level'].upper()))
    cca_logger = logging.getLogger('ClientCredentialsAuth')
    cca_logger.setLevel(getattr(logging, args['log_level_client'].upper()))
    this_logger = logging.getLogger(ACTION_ID)
    this_logger.setLevel(getattr(logging, args['log_level_this'].upper()))

    keycloak_client = get_rest_client()

    creds = service_account.Credentials.from_service_account_file(
        args['sa_credentials'], subject=args['sa_subject'],
        scopes=['https://www.googleapis.com/auth/calendar'])

    asyncio.run(sync_gws_calendars(creds, keycloak_client, args['dryrun'], args['notify']))


if __name__ == '__main__':
    sys.exit(main())
